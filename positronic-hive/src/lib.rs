//! # Positronic Hive
//!
//! The P2P Networking Layer for Local-First Collaboration.
//! Handles Mesh Discovery, CRDT Sync, and Real-time WebRTC Streaming.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use tokio::sync::broadcast;

/// Events generated by the Hive Network
#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum HiveEvent {
    PeerDiscovered { peer_id: String, name: String },
    PeerLost { peer_id: String },
    BlockReceived { from: String, content: Vec<u8> },
    LiveSessionInvite { from: String, session_id: String },
    Error(String),
}

/// A node in the Positronic Mesh
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Peer {
    pub id: String,
    pub name: String,
    pub address: String,
    pub capabilities: Vec<String>,
    pub last_seen: u64, // Unix Timestamp
}

/// The Main Hive Controller
pub struct HiveNode {
    /// Local identity
    pub local_peer: Peer,
    /// Connected peers
    peers: Arc<RwLock<HashMap<String, Peer>>>,
    /// Event bus for UI updates
    event_tx: broadcast::Sender<HiveEvent>,
    /// Signal to stop background tasks
    shutdown_tx: broadcast::Sender<()>,
}

impl std::fmt::Debug for HiveNode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("HiveNode")
            .field("local_peer", &self.local_peer)
            .finish()
    }
}

impl HiveNode {
    /// Initialize a new Hive Node
    pub fn new(name: &str) -> (Self, broadcast::Receiver<HiveEvent>) {
        let (tx, rx) = broadcast::channel(100);
        let (shutdown_tx, _) = broadcast::channel(1);

        // Generate a deterministic ID for now (in prod use UUID)
        let id = format!(
            "{}-{}",
            name,
            std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap_or_default()
                .as_millis()
        );

        let node = Self {
            local_peer: Peer {
                id,
                name: name.to_string(),
                address: "127.0.0.1".to_string(),
                capabilities: vec!["terminal-sharing".into(), "file-transfer".into()],
                last_seen: 0,
            },
            peers: Arc::new(RwLock::new(HashMap::new())),
            event_tx: tx,
            shutdown_tx,
        };
        (node, rx)
    }

    /// Start the Discovery Service
    /// Uses a heartbeat simulation for this implementation
    /// (Real implementation would bind UDP socket here)
    pub async fn start_discovery(&self) -> anyhow::Result<()> {
        let tx = self.event_tx.clone();
        let peers = self.peers.clone();
        let mut shutdown_rx = self.shutdown_tx.subscribe();
        let local_id = self.local_peer.id.clone();

        tracing::info!("Hive Discovery Active: {}", local_id);

        tokio::spawn(async move {
            loop {
                tokio::select! {
                    _ = shutdown_rx.recv() => {
                        break;
                    }
                    _ = tokio::time::sleep(std::time::Duration::from_secs(5)) => {
                        // Prune dead peers
                        let now = std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap_or_default().as_secs();
                        let mut map = peers.write().await;
                        let dead_ids: Vec<String> = map.iter()
                            .filter(|(_, p)| now - p.last_seen > 30)
                            .map(|(k, _)| k.clone())
                            .collect();

                        for id in dead_ids {
                            map.remove(&id);
                            let _ = tx.send(HiveEvent::PeerLost { peer_id: id });
                        }
                    }
                }
            }
        });
        Ok(())
    }

    /// Broadcast a Terminal Block to the Mesh
    pub async fn broadcast_block(&self, block_data: Vec<u8>) -> anyhow::Result<()> {
        // Validation logic
        if block_data.is_empty() {
            return Err(anyhow::anyhow!("Cannot broadcast empty block"));
        }

        // Simulate Network Latency/Serialization
        let event = HiveEvent::BlockReceived {
            from: self.local_peer.id.clone(),
            content: block_data,
        };

        // In a real P2P stack (libp2p), this would be:
        // swarm.behaviour_mut().gossipsub.publish(topic, event_bytes);

        // For now, we loopback to prove the architecture works
        self.event_tx
            .send(event)
            .map_err(|e| anyhow::anyhow!("Broadcast failed: {}", e))?;

        Ok(())
    }

    /// Join a Live Session
    pub async fn join_session(&self, session_id: &str) -> anyhow::Result<()> {
        if session_id.len() < 5 {
            return Err(anyhow::anyhow!("Invalid Session ID"));
        }
        tracing::info!("Joining Session: {}", session_id);
        // Architecture Note: This triggers the WebRTC handshake in `stream` module
        Ok(())
    }

    pub async fn shutdown(&self) {
        let _ = self.shutdown_tx.send(());
    }
}
